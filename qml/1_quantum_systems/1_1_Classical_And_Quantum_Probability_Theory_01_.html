<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classical and Quantum Probability Theory &mdash; Daniel Mo Houshmand</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sphinx-thebe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/exercise.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/QDaria.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mo_addmination.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/QDaria.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mo_addmination.css" type="text/css" />
    <link rel="canonical" href="https://qdaria.com/qml/1_quantum_systems/1_1_Classical_And_Quantum_Probability_Theory_01_.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
        <script src="../../_static/tabs.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script src="../../_static/design-tabs.js"></script>
        <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
        <script async="async" src="../../_static/sphinx-thebe.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Quantum Computations" href="../2_quantum_computations/2_quantum_computations.html" />
    <link rel="prev" title="Quantum Systems" href="1_quantum_systems.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/D62.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Quantum Computers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/0_QC/0_quantum_computers.html">1. Into the Hardware of Quantum Computers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/1_spin/1_0_spin.html">2. Spin-Based and Molecular Approaches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/3_superconducting/3_0_superconducting.html">3. Superconductivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/4_topological_qubits/4_0_topological.html">4. Topological Qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/5_adiabatic_hybrid/5_0_adiabatic.html">5. Adiabatic Quantum Computers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/6_semiconductors/6_0_semicunductors.html">6. Semiconductor-based qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/7_trapped/7_0_trapped.html">7. Trapped Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/8_photonic/8_0_photonic.html">8. Photonic and Optical Approaches</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantum Machine Learning</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="1_quantum_systems.html">Quantum Systems</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Classical and Quantum Probability Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-machine-learning-an-emerging-phenomenon">Quantum Machine Learning: An Emerging Phenomenon</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-probability-distributions">Classical Probability Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-geometry-of-probability-distribution">The Geometry of Probability Distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stochastic-matrix">Stochastic Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-states">Quantum states</a></li>
<li class="toctree-l2"><a class="reference internal" href="#qubits-revisited">Qubits revisited</a></li>
<li class="toctree-l2"><a class="reference internal" href="#superposition-revisited">Superposition revisited</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bloch-sphere-revisited">Bloch Sphere revisited</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interference">Interference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-qubits-and-entanglement">More qubits and entanglement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-qubits-revisited">Multiple Qubits revisited</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">Further reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2_quantum_computations/2_quantum_computations.html">Quantum Computations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_Classical_Quantum_Hybrid_Learning_Algorithms/3_Classical_Quantum_Hybrid_Learning_Algorithms.html">Classical Quantum Hybrid Learning Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_Coherent_Learning_Protocols/4_Coherent_Learning_Protocols.html">Coherent Learning Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_quantumkernels/5_quantumkernels.html">Quantum Kernels</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="1_quantum_systems.html">Quantum Systems</a></li>
      <li class="breadcrumb-item active">Classical and Quantum Probability Theory</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/qml/1_quantum_systems/1_1_Classical_And_Quantum_Probability_Theory_01_.ipynb" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="classical-and-quantum-probability-theory">
<h1>Classical and Quantum Probability Theory<a class="headerlink" href="#classical-and-quantum-probability-theory" title="Permalink to this headline"></a></h1>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-row docutils">
<div class="sd-card sd-sphinx-override sd-w-100 sd-shadow-lg docutils">
<div class="sd-card-body docutils">
<div class="sd-col sd-d-flex-row docutils">
<div class="sd-card sd-sphinx-override sd-w-100 sd-shadow-lg docutils">
<div class="sd-card-body docutils">
<p class="sd-card-text"><img alt="D58" src="qml/1_quantum_systems/_static/D52.png" /></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Consider a classical bit, which is binary and often likened to an impartial coin toss - with Heads <span class="math notranslate nohighlight">\((H)\)</span> or Tails <span class="math notranslate nohighlight">\((T)\)</span> as the outcomes. This can be mathematically formulated as:</p>
<div class="math notranslate nohighlight">
\[ P(H)=P(T)=0.5 \]</div>
<p>Contrarily, a quantum bit, popularly termed a qubit, visualizes as a rotating coin in suspense of its landing state - perceptionally exhibiting the characteristics of a sphere in its spinning phase.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-machine-learning-an-emerging-phenomenon">
<h1>Quantum Machine Learning: An Emerging Phenomenon<a class="headerlink" href="#quantum-machine-learning-an-emerging-phenomenon" title="Permalink to this headline"></a></h1>
<p>Traditional machine learning is concerned with the capacity of conventional computers to perceive patterns within data. However, Quantum Machine Learning (QML) expands this to explore the ability of Quantum Computers and similar quantum informational processors to discern patterns in data that remain beyond the apprehension of classical machine learning algorithms.</p>
<p>Quantum states, defined by their precise properties that set them apart from classical probabilities, are instrumental in forming an intuitive understanding of quantum computing. This differentiation provides an accessible groundwork for the essential concepts required in quantum computing.</p>
<p>Linear algebra, alike probability theory, is indispensable for numerous learning protocols. Fundamentally, quantum computing is a manifestation of linear algebra. An insightful correlation will be drawn between quantum computing, geometry, and probabilities, shedding light on their intrinsic links. Familiarity with geometric notions can further aid in appreciating classical probability distributions. Initiating with a discussion on classical probabilities and stochastic vectors, this notebook will introduce quantum states as a progressive extension of these elements.</p>
<p>Throughout this course, we will confine our assumptions to finite probability distributions and finite-dimensional spaces. This abbreviation considerably eases notation renditions, while not sacrificing much since a majority of quantum computers operate within finite-dimensional realms.</p>
<p>Upon introducing quantum states as an extension of classical probability distributions and quantum computations as a method for transforming these probability distributions, we will briefly examine the components of classical probability theory before delving further into quantum states and quantum computations. A look into coin flipping serves as a useful introduction. It offers two prospective outcomes– heads or tails. Each outcome is associated with a certain probability, P0 for heads and P1 for tails.</p>
<p>In essence, classical probability distributions can be considered as a specific instance within the broader scope of quantum states. Furthermore, the transformation of these probability distributions is the crux of quantum computation. Upon exploring classical probability theory elements, we arrive at the occurrence of a coin flip. With two potential outcomes - heads or tails, equal probabilities are assigned to each outcome - P0 associated with heads and P1 associated with tails. In a formalized context, the probability of outcome X being the ‘head’ (H) is designated as P0. Similarly, this applies to the outcome being ‘tail’.</p>
<p>Probability theory forms a crucial foundation for machine learning, and quantum states can be perceived as probability distributions with distinctive properties that differentiate them from the classical understanding of probabilities. Examining these differences serves as a basic yet essential primer towards comprehending quantum computing.</p>
<p>In addition to probability theory, linear algebra is critically important for various learning methods. Interestingly, the domains of geometry and probabilities are integrally correlated in quantum computing. However, such geometric concepts are not unfamiliar when dealing with classical probability distributions. This notebook will begin by discussing classical probabilities and stochastic vectors, eventually paving the way to introduce quantum states as their natural evolution.</p>
<p>In the context of this course, we will operate under the presumption of finite probability distributions and finite-dimensional spaces. This approach significantly eases the complexity of notation, and since most quantum computers operate within finite-dimensional spaces, the overall generality of the course remains unaffected.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="classical-probability-distributions">
<h1>Classical Probability Distributions<a class="headerlink" href="#classical-probability-distributions" title="Permalink to this headline"></a></h1>
<p>Consider an instance where we toss a biased coin. Without delving into technical specifics, we can assign a random variable <span class="math notranslate nohighlight">\(X\)</span> to represent the result - it assumes the value 0 for ‘Heads’ and the value 1 for ‘Tails’. The occurrence of ‘Heads’ can be denoted with a probability <span class="math notranslate nohighlight">\(P(X=0) = p_0\)</span>, and ‘Tails’ with <span class="math notranslate nohighlight">\(P(X=1) = p_1\)</span>. As per classical Kolmogorovian probability theory, each probability <span class="math notranslate nohighlight">\(p_i\)</span> is always greater than or equal to 0, and the sum of all probabilities equals 1, or mathematically, <span class="math notranslate nohighlight">\(\sum_i p_i = 1\)</span>. Following this understanding, let’s proceed to sample this distribution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">dash</span>
<span class="kn">from</span> <span class="nn">dash</span> <span class="kn">import</span> <span class="n">dcc</span><span class="p">,</span> <span class="n">html</span>
<span class="kn">from</span> <span class="nn">dash.dependencies</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Output</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="c1"># Initialize the app</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">dash</span><span class="o">.</span><span class="n">Dash</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Define the app layout</span>
<span class="n">app</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="n">Div</span><span class="p">([</span>
    <span class="n">html</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="s1">&#39;Flip Coin&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;flip-button&#39;</span><span class="p">,</span> <span class="n">n_clicks</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">html</span><span class="o">.</span><span class="n">Div</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;result-div&#39;</span><span class="p">)</span>
<span class="p">])</span>

<span class="c1"># Define callback to update coin flip result</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span>
    <span class="n">Output</span><span class="p">(</span><span class="s1">&#39;result-div&#39;</span><span class="p">,</span> <span class="s1">&#39;children&#39;</span><span class="p">),</span>
    <span class="p">[</span><span class="n">Input</span><span class="p">(</span><span class="s1">&#39;flip-button&#39;</span><span class="p">,</span> <span class="s1">&#39;n_clicks&#39;</span><span class="p">)]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">update_result</span><span class="p">(</span><span class="n">n_clicks</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n_clicks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coin_sides</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Heads&#39;</span><span class="p">,</span> <span class="s1">&#39;Tails&#39;</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">coin_sides</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;The result is: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;Press the button to flip the coin.&quot;</span>

<span class="c1"># Run the app</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run_server</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dash is running on http://127.0.0.1:8050/
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> * Serving Flask app &#39;__main__&#39;
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> * Debug mode: on
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel_launcher.py&quot;, line 17, in &lt;module&gt;
    app.launch_new_instance()
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/traitlets/config/application.py&quot;, line 1042, in launch_instance
    app.initialize(argv)
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/traitlets/config/application.py&quot;, line 113, in inner
    return method(app, *args, **kwargs)
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel/kernelapp.py&quot;, line 678, in initialize
    self.init_sockets()
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel/kernelapp.py&quot;, line 317, in init_sockets
    self.shell_port = self._bind_socket(self.shell_socket, self.shell_port)
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel/kernelapp.py&quot;, line 252, in _bind_socket
    return self._try_bind_socket(s, port)
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel/kernelapp.py&quot;, line 228, in _try_bind_socket
    s.bind(&quot;tcp://%s:%i&quot; % (self.ip, port))
  File &quot;/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/zmq/sugar/socket.py&quot;, line 302, in bind
    super().bind(addr)
  File &quot;zmq/backend/cython/socket.pyx&quot;, line 564, in zmq.backend.cython.socket.Socket.bind
  File &quot;zmq/backend/cython/checkrc.pxd&quot;, line 28, in zmq.backend.cython.checkrc._check_rc
zmq.error.ZMQError: Address already in use (addr=&#39;tcp://127.0.0.1:56945&#39;)
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="n">An</span> <span class="n">exception</span> <span class="n">has</span> <span class="n">occurred</span><span class="p">,</span> <span class="n">use</span> <span class="o">%</span><span class="k">tb</span> to see the full traceback.

<span class="ne">SystemExit</span>: 1
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/moh/micromamba/envs/mom1env/lib/python3.8/site-packages/IPython/core/interactiveshell.py:3516: UserWarning: To exit: use &#39;exit&#39;, &#39;quit&#39;, or Ctrl-D.
  warn(&quot;To exit: use &#39;exit&#39;, &#39;quit&#39;, or Ctrl-D.&quot;, stacklevel=1)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_1</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0
 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0
 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>numpy.ndarray
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_data</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>14
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;H&#39;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="k">else</span> <span class="s1">&#39;T&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span> <span class="o">=</span> <span class="p">[</span><span class="n">flip</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="nb">float</span><span class="p">(</span><span class="n">flips</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.57
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span> <span class="o">=</span> <span class="p">[</span><span class="n">flip</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="nb">float</span><span class="p">(</span><span class="n">flips</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.49
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">flips</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;T&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">string</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span>
    <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span>
    <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span>
    <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span>
    <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span>
    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="s1">&#39;11&#39;</span><span class="p">,</span>
    <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="s1">&#39;12&#39;</span><span class="p">,</span>
    <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="s1">&#39;13&#39;</span><span class="p">,</span>
    <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;14&#39;</span><span class="p">,</span>
    <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span>
    <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="s1">&#39;16&#39;</span><span class="p">,</span>
    <span class="s1">&#39;q&#39;</span><span class="p">:</span> <span class="s1">&#39;17&#39;</span><span class="p">,</span>
    <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;18&#39;</span><span class="p">,</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="s1">&#39;19&#39;</span><span class="p">,</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;20&#39;</span><span class="p">,</span>
    <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="s1">&#39;21&#39;</span><span class="p">,</span>
    <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="s1">&#39;22&#39;</span><span class="p">,</span>
    <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="s1">&#39;23&#39;</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;24&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;25&#39;</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;26&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">word</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> w
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>23
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span>
   <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>23
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># for inline plots in jupyter</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="c1"># import matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># for latex equations</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Math</span><span class="p">,</span> <span class="n">Latex</span>
<span class="c1"># for displaying images</span>
<span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="c1"># import seaborn</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="c1"># settings for seaborn plotting style</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">color_codes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># settings for seaborn plot sizes</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">:(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="c1"># generate random numbers from N(0,1)</span>
<span class="n">data_normal</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="n">data_normal</span><span class="p">,</span>
                  <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                  <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span>
                  <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Normal Distribution&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
  warnings.warn(msg, FutureWarning)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Text(0.5, 0, &#39;Normal Distribution&#39;), Text(0, 0.5, &#39;Frequency&#39;)]
</pre></div>
</div>
<img alt="../../_images/ca6dc1bc47cbd8ade4577ec615f1042acef3fc36f28bad4ef4a0e3d4208254db.png" src="../../_images/ca6dc1bc47cbd8ade4577ec615f1042acef3fc36f28bad4ef4a0e3d4208254db.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#[Text(0,0.5,u&#39;Frequency&#39;), Text(0.5,0,u&#39;Normal Distribution&#39;)]</span>
</pre></div>
</div>
</div>
</div>
<p>https://www.kaggle.com/nowke9/statistics-2-distributions</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">bernoulli</span>
<span class="n">data_bern</span> <span class="o">=</span> <span class="n">bernoulli</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span><span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="n">data_bern</span><span class="p">,</span>
                 <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#False</span>
                 <span class="n">color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span>
                 <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Bernoulli Distribution&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
  warnings.warn(msg, FutureWarning)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Text(0.5, 0, &#39;Bernoulli Distribution&#39;), Text(0, 0.5, &#39;Frequency&#39;)]
</pre></div>
</div>
<img alt="../../_images/2e1fdc2dd5d443b425ab5465e5744b332cf3db0dac0a01903b11beb30a71b7b1.png" src="../../_images/2e1fdc2dd5d443b425ab5465e5744b332cf3db0dac0a01903b11beb30a71b7b1.png" />
</div>
</div>
<p>https://www.datacamp.com/community/tutorials/probability-distributions-python</p>
<p><strong>End Test</strong></p>
<p>We naturally expect that the empirically observed frequencies also sum to one:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">frequency_of_zeros</span><span class="p">,</span> <span class="n">frequency_of_ones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">frequency_of_ones</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_samples</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">frequency_of_zeros</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_samples</span>
<span class="nb">print</span><span class="p">(</span><span class="n">frequency_of_ones</span><span class="o">+</span><span class="n">frequency_of_zeros</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0000000000000004
</pre></div>
</div>
</div>
</div>
<p>Given that <span class="math notranslate nohighlight">\(p_0\)</span> and <span class="math notranslate nohighlight">\(p_1\)</span> must be non-negative, all potential probability distributions can be confined to the positive orthant. The normalization constraint further distils all potential distributions to lie on a straight line. The plot that follows graphically represents all conceivable probability distributions derived from biased and unbiased coins.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="n">p_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p_0</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$p_0$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$p_1$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_0</span><span class="p">,</span> <span class="n">p_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x287e01c90&gt;]
</pre></div>
</div>
<img alt="../../_images/4017629a3f3aca2381b4da6387b9d6f6b8ee38174fd7df21692d7595e6c394f9.png" src="../../_images/4017629a3f3aca2381b4da6387b9d6f6b8ee38174fd7df21692d7595e6c394f9.png" />
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="the-geometry-of-probability-distribution">
<h1>The Geometry of Probability Distribution<a class="headerlink" href="#the-geometry-of-probability-distribution" title="Permalink to this headline"></a></h1>
<p>Delving into the geometry of this probability distribution, we see it can also be represented as a vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{p}=\left[\begin{array}{c}
p_{0}\\
p_{1}
\end{array}\right]\end{split}\]</div>
<p>This vector representation is referred to as a stochastic vector. If we transpose these probability values into a column vector (and denote it with an arrow above the P to indicate it’s a vector), we find a comparable process in quantum states. Quantum states are generally depicted by a column vector with a notation signifying it as a column vector. All the components are non-negative real values, and their sum equals 1.</p>
<p>However, the summation is identical to the summation of the absolute value, considering we are dealing with non-negative numbers. This suggests that we normalize the P vector in the 1-norm, consequently, it’s normed to 1 in the 1-norm.</p>
<div class="math notranslate nohighlight">
\[\sum_{i}p_{i}=\sum_{i}\mid p_{i}\mid=\mid\boldsymbol{p}\mid_{1}\]</div>
<p>This is particularly important as the normalization in quantum states will happen in a different norm.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="stochastic-matrix">
<h1>Stochastic Matrix<a class="headerlink" href="#stochastic-matrix" title="Permalink to this headline"></a></h1>
<p>Lastly, we will inspect how we transform probability distributions. Currently, we possess this stochastic vector and aim to acquire another stochastic vector, subsequently another probability distribution. The transformation applied to this vector should meet certain conditions to ensure this.</p>
<div class="math notranslate nohighlight">
\[M\boldsymbol{p}=\boldsymbol{p}'\]</div>
<p>Here, M represents a left-stochastic matrix. $<span class="math notranslate nohighlight">\(p_{i}'\geq0\)</span>$</p>
<div class="math notranslate nohighlight">
\[\mid\mid\boldsymbol{p}\mid\mid_{1}=1\]</div>
<p>In the case of a left-stochastic matrix (indicating its application to the left of the stochastic vector), the summation of the columns equates to 1. Quantum computations will also involve matrix operations fulfilling certain mathematical properties. They are unitary operations, transforming quantum states, or quantum probabilities, into other quantum states.</p>
<section id="quiz-on-classical-probability-distribution">
<h2>Quiz on Classical Probability Distribution<a class="headerlink" href="#quiz-on-classical-probability-distribution" title="Permalink to this headline"></a></h2>
<p><strong>All classical probability distributions of coin flipping lie on…</strong></p>
<p>– A unit circle within the <span class="math notranslate nohighlight">\(l_{1}\)</span> norm, restricted to the positive orthant.</p>
<p><strong>You are given a biased 6-sided dice where side 1 has a higher probability than all the other sides. The entropy is…</strong></p>
<p>– Lower than <span class="math notranslate nohighlight">\(\log_{2}6\)</span>.</p>
<p><strong>A stochastic matrix</strong></p>
<p>– Transforms a stochastic vector into another stochastic vector.</p>
<p>We can also organize the probabilities in a vector:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vec{p} = \begin{bmatrix} p_0 \\ p_1 \end{bmatrix}\end{split}\]</div>
<p>For ease of notation, we will denote vectors with an arrow above the variable to distinguish them from scalars. Notably, quantum states also have standard notation facilitating convenience and offering more practical advantages than the simple arrow.</p>
<p>A vector representing a probability distribution is termed a <em>stochastic vector</em>. The normalization constraint fundamentally signifies that the norm of the vector is confined to one within the <span class="math notranslate nohighlight">\(l_1\)</span> norm - mathematically expressed as,</p>
<div class="math notranslate nohighlight">
\[\mid \mid \vec{p}\mid \mid_{1} = \sum_i |p_i| = 1\]</div>
<p>While this corresponds to the unit circle within the <span class="math notranslate nohighlight">\(l_1\)</span> norm, the condition <span class="math notranslate nohighlight">\(p_i\geq 0\)</span> restricts us to a quarter of the unit circle, as shown in the above plot. The validity of this can be easily confirmed using the numpy’s norm function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> chapyter
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start to install package: redis
successfully installed package: redis
start to install package: redis_om
successfully installed package: redis_om
</pre></div>
</div>
</div>
</div>
<p>We know that the probability of heads is just the first element in the <span class="math notranslate nohighlight">\(\vec{p}\)</span>, but since it is a vector, we could use linear algebra to extract it. Geometrically, it means that we project the vector to the first axis. This projection is described by the matrix
$<span class="math notranslate nohighlight">\(\begin{bmatrix} 1 &amp; 0\\0 &amp; 0\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
The length in the \)</span>l_1$ norm gives the sought probability:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Π_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Π_0</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.8
</pre></div>
</div>
</div>
</div>
<p>We can repeat the process to get the probability of tails:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Π_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Π_1</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2
</pre></div>
</div>
</div>
</div>
<p>The two projections play an equivalent role to the values 0 and 1 when we defined the probability distribution. In fact, we could define a new random variable called <span class="math notranslate nohighlight">\(\Pi\)</span> that can take the projections <span class="math notranslate nohighlight">\(\Pi_0\)</span> and <span class="math notranslate nohighlight">\(\Pi_1\)</span> as values and we would end up with an identical probability distribution. This may sound convoluted and unnatural, but the measurement in quantum mechanics is essentially a random variable that takes operator values, such as projections.</p>
<p>What happens when we want to transform a probability distribution to another one? For instance, to change the bias of a coin, or to describe the transition of a Markov chain. Since the probability distribution is also a stochastic vector, we can apply a matrix on the vector, where the matrix has to fulfill certain conditions. A left <em>stochastic matrix</em> will map stochastic vectors to stochastic vectors when multiplied from the left: its columns add up to one. In other words, it maps probability distributions to probability distributions. For example, starting with a unbiased coin, the map <span class="math notranslate nohighlight">\(M\)</span> will transform the distribution to a biased coin:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]])</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.9999999999999999
</pre></div>
</div>
</div>
</div>
<p>One last concept that will come handy is entropy. A probability distribution’s entropy is defined as
$<span class="math notranslate nohighlight">\(H(p) = - \sum_i p_i \log_2 p_i\)</span>$</p>
<p>And the plot over all possible probability distributions of coin tosses:</p>
</section>
<section id="entropy">
<h2>Entropy<a class="headerlink" href="#entropy" title="Permalink to this headline"></a></h2>
<p>Now let’s pay attention to another concept called <strong>entropy</strong>. Entropy is a characterization of a probability distribution, and tells something about its unpredictability. It peaks at the unbiased coin, which is the uniform distribution and we’ll get all outcomes with the same probability. This is the most unpredictable case where in this case, we flip the coin, we have absolutely no predictive power of what the next coin flip is going to give us. Whereas if the coin is biased either way, it has a lower complexity and it becomes easier to make probabilistic predictions about the future outcome.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ϵ</span> <span class="o">=</span> <span class="mf">10e-10</span>
<span class="n">p_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ϵ</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">ϵ</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p_0</span>
<span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">p_0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_1</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$p_0$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$H$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_0</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.lines.Line2D at 0x287de3e20&gt;
</pre></div>
</div>
<img alt="../../_images/c1cd51a214bf61909431df7117b1b2cb1b259fb6c542398c261a34b51f4c1e2c.png" src="../../_images/c1cd51a214bf61909431df7117b1b2cb1b259fb6c542398c261a34b51f4c1e2c.png" />
</div>
</div>
<p>Here we can see that the entropy is maximal for the unbiased coin. This is true in general: the entropy peaks for the uniform distribution. In a sense, this is the most unpredictable distribution: if we get heads with probability 0.2, betting tails is a great idea. On the other hand, if the coin is unbiased, then a deterministic strategy is of little help in winning. Entropy quantifies this notion of surprise and unpredictability.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-states">
<h1>Quantum states<a class="headerlink" href="#quantum-states" title="Permalink to this headline"></a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="qubits-revisited">
<h1>Qubits revisited<a class="headerlink" href="#qubits-revisited" title="Permalink to this headline"></a></h1>
<p>In the previous we introduced classical probability theories and the stochastic vector, which describes a probability distribution. So, based on that, we can easily introduce quantum states. So a quantum state is just like stochastic vector. You can write it as a column vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>But the big difference is that you are not restricted to real numbers and nonnegative real numbers, because the entries in this vector are complex values. And the normalization of this vector doesn’t happen in the one norm, it happens in the two norm.</p>
<div class="math notranslate nohighlight">
\[\Vert\mid\psi\rangle\Vert_{2}=1\]</div>
<p>So it’s still normalizing to <span class="math notranslate nohighlight">\(1\)</span>, but now the square sum of the absolute values of the entries is what adds up to 1, as opposed to just the absolute values adding up to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>This is the simplest possible quantum state. It has two possible outcomes. This is often referred to as a qubit.</p>
<p><strong>Finish</strong></p>
<p>A classical coin is a two-level system: it is either heads or tails. At a first look a quantum state is a probability distribution, and the simplest case is a two-level state, which we call a qubit. Just like the way we can write the probability distribution as a column vector, we can write a quantum state as a column vector. For notational convenience that will become apparent later, we write the label of a quantum state in what is called a ket in the Dirac notation. So for instance, for some qubit, we can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid \psi\rangle = \begin{bmatrix}a_0 \\ a_1 \\\end{bmatrix}\end{split}\]</div>
<p>In other words, a ket is just a column vector, exactly like the stochastic vector in the classical case. Instead of putting an arrow over the name of the variable to express that it is a vector, we use the ket to say that it is a column vector that represents a quantum state. There’s more to this notation, as we will see.</p>
<p>The key difference to classical probability distributions and stochastic vectors is the normalization constraint. The square sum of their absolute values adds up to 1:</p>
<div class="math notranslate nohighlight">
\[\sqrt{|a_0|^2+|a_1|^2}=1\]</div>
<p>where
$<span class="math notranslate nohighlight">\(a_0, a_1\in \mathbb{C}\)</span>$</p>
<p>In other words, we are normalizing in the <span class="math notranslate nohighlight">\(l_2\)</span> norm instead of the <span class="math notranslate nohighlight">\(l_1\)</span> norm. Furthermore, we are no longer restricted to the positive orthant: the components of the quantum state vector, which we call <em>probability amplitudes</em>, are complex valued.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="superposition-revisited">
<h1>Superposition revisited<a class="headerlink" href="#superposition-revisited" title="Permalink to this headline"></a></h1>
<p>And a superposition is just the expansion of this vector in a basis. For instance, if it expanded in the canonical basis, like this, then we can introduce a notation for the <span class="math notranslate nohighlight">\(1 0\)</span> vector and the <span class="math notranslate nohighlight">\(0 1\)</span> vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]=a_{0}\left[\begin{array}{c}1\\0\end{array}\right]+a_{1}\left[\begin{array}{c}0\\1\end{array}\right]=a_{0}\mid0\rangle+a_{1}\mid1\rangle\end{split}\]</div>
<p>Outcome <span class="math notranslate nohighlight">\(0\)</span> with probability
$<span class="math notranslate nohighlight">\(\mid a_{0}\mid^{2}\)</span>$</p>
<p>state afterwards:
$<span class="math notranslate nohighlight">\(\mid0\rangle\)</span>$</p>
<p>Now the</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c}1\\0\end{array}\right]\end{split}\]</div>
<p>is called the 0 ket
$<span class="math notranslate nohighlight">\(\mid0\rangle\)</span>$</p>
<p>And the
$<span class="math notranslate nohighlight">\(\left[\begin{array}{c}0\\1\end{array}\right]\)</span>$</p>
<p>the second basis vector, is called the 1 ket</p>
<div class="math notranslate nohighlight">
\[\mid1\rangle\]</div>
<p>And this notation, the vertical bar, and this little angle, often the name of the vector– is ket. This gives us the same idea as in a stochastic vector, that we have to put an arrow on top of the vector, that will help us in the syntax of writing calculations on the quantum states. Here</p>
<div class="math notranslate nohighlight">
\[a_{0}\mid0\rangle+a_{1}\mid1\rangle\]</div>
<p>is the superposition of the <span class="math notranslate nohighlight">\(0\)</span> and the <span class="math notranslate nohighlight">\(1 ket\)</span> , with different coefficients <span class="math notranslate nohighlight">\(a_{0}\)</span> and <span class="math notranslate nohighlight">\(a_{1}\)</span>. So these coefficients are called probability amplitudes. They no longer represent probabilities directly, as in the case of a stochastic vector, but it’s the absolute value squared of these values what gives you a probability. So, for instance, you get the outcome 0, with probability a0 squared and, similarly, outcome 1, with probability of the absolute value of a1 squared. And, once you get an outcome 0,</p>
<div class="math notranslate nohighlight">
\[a_{0}\mid0\rangle+a_{1}\mid1\rangle\]</div>
<p>you know that the state is in the 0 state. And similarly, if you get the outcome 1, afterwards the state is going to be in the state 1. This is called the “collapse of the wave function.” A quantum state is also called a wave function. And basically, once you pull out a sample of this distribution and you get an outcome, you make that observation, then you get the deterministic state afterwards, after the random outcome. So you can also think about it in a more geometric way. So now you have a two-dimensional complex space which would take a four dimensions to visualize. But we have this restriction on the degree of freedom. So we can have some three-dimensional object representing these qubit states.</p>
<p>Let us introduce two special qubits, corresponding to the canonical basis vectors in two dimensions:
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
and 
\)</span><span class="math notranslate nohighlight">\(\mid 1\rangle\)</span>$</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid 0\rangle = \begin{bmatrix} 1 \\ 0 \\ \end{bmatrix}, \,\,\, \mid 1\rangle = \begin{bmatrix} 0 \\ 1 \\ \end{bmatrix}\end{split}\]</div>
<p>This basis is also called the computational basis in quantum computing.</p>
<p>We can expand an arbitrary qubit state in this basis:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid \psi\rangle = \begin{bmatrix}a_0 \\ a_1 \\ \end{bmatrix}=a_0\begin{bmatrix}1 \\0 \\\end{bmatrix} + a_1\begin{bmatrix} 0 \\ 1 \\ \end{bmatrix}= a_0 \mid 0\rangle+a_1 \mid 1\rangle\end{split}\]</div>
<p>This expansion in a basis is called a superposition. If we sample the qubit state, we obtain the outcome 0 with probability <span class="math notranslate nohighlight">\(|a_0|^2\)</span>, and 1 with probability <span class="math notranslate nohighlight">\(|a_1|^2\)</span>. This is known as the Born rule; you will learn more about measurements and this rule in a subsequent notebook.</p>
<p>For now, let’s take a look at how we can simulate classical coin tossing on a quantum computer. Let’s start with a completely biased case where we get heads with probability 1. This means that our qubit <span class="math notranslate nohighlight">\(|\psi\rangle=|0\rangle\)</span>. We create a circuit of a single qubit and a single classical register where the results of the sampling (measurements) go.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumRegister</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">execute</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">BasicAer</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span><span class="p">,</span> <span class="n">plot_bloch_multivector</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">π</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">backend</span> <span class="o">=</span> <span class="n">BasicAer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Any qubit is initialized in <span class="math notranslate nohighlight">\(|0\rangle\)</span>, so if we measure it right away, we should get our maximally biased coin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;qiskit.circuit.instructionset.InstructionSet at 0x10f511390&gt;
</pre></div>
</div>
</div>
</div>
<p>Let us execute it a hundred times and study the result</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;0&#39;: 100}
</pre></div>
</div>
</div>
</div>
<p>As expected, all of our outcomes are 0.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="bloch-sphere-revisited">
<h1>Bloch Sphere revisited<a class="headerlink" href="#bloch-sphere-revisited" title="Permalink to this headline"></a></h1>
<p>So this is where the Bloch sphere helps us. So Bloch sphere is this three-dimensional sphere, but with a slightly different geometry than a normal sphere. So here the north pole is identified with the 0 ket, and the south pole is identified with the 1 ket.</p>
<p>It’s a little bit unusual, because these two basis vectors are actually orthogonal. And it gives an illusion as if they’re relying on the same line. So just keep in mind that orthogonality is a little bit different in this sphere. And now every single point on the surface of the sphere is a qubit state</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>So, basically, you have a much larger representative power. If you compare it, for instance, with classical probability distributions, where every single probability distribution lies on this straight line, as opposed to this large, two-dimensional surface of the Bloch sphere. Now, there are a couple of things that we can do with quantum states which we cannot do, for instance, in classical digital computers. <br></p>
<p>To understand the possible quantum states, we use the Bloch sphere visualization. Since the probability amplitudes are complex and there are two of them for a single qubit, this would require a four-dimensional space. Now since the vectors are normalized, this removes a degree of freedom, allowing a three-dimensional representation with an appropriate embedding. This embedding is the Bloch sphere. It is slightly different than an ordinary sphere in three dimensions: we identify the north pole with the state
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
and the south pole with \)</span>|1\rangle$. In other words, two orthogonal vectors appear as if they were on the same axis – the axis Z. The computational basis is just one basis: the axes X and Y represent two other bases. Any point on the surface of this sphere is a valid quantum state. This is also true the other way around: every pure quantum state is a point on the Bloch sphere. Here it ‘pure’ is an important technical term and it essentially means that the state is described by a ket (column vector). Later in the course we will see other states called mix states that are not described by a ket (you will see later that these are inside the Bloch sphere).</p>
<p>To make it less abstract, let’s plot our
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span>$
on the Bloch sphere:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend_statevector</span> <span class="o">=</span> <span class="n">BasicAer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;statevector_simulator&#39;</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">#circuit.iden(q[0])</span>
<span class="c1">#QuantumCircuit.iden(q[0])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/34da282e5c7ce041060e209d91c05150d0eab09c93848a75db7f726ebb5087be.png" src="../../_images/34da282e5c7ce041060e209d91c05150d0eab09c93848a75db7f726ebb5087be.png" />
</div>
</div>
<p>Compare this sphere with the straight line in the positive orthant that describes all classical probability distributions of coin tosses. You can already see that there is a much richer structure in the quantum probability space.</p>
<p>Let us pick another point on the Bloch sphere, that is, another distribution. Let’s transform the state
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
to 
\)</span><span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\)</span><span class="math notranslate nohighlight">\( 
This corresponds to the unbiased coin, since we will get 0 with probability 
\)</span><span class="math notranslate nohighlight">\(\mid\frac{1}{\sqrt{2}}|^2=1/2\)</span><span class="math notranslate nohighlight">\( 
and the other way around. There are many ways to do this transformation. We pick a rotation around the Y axis by \)</span>\pi/2<span class="math notranslate nohighlight">\(, which corresponds to the matrix 
\)</span><span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; -1\\1 &amp; 1\end{bmatrix}\)</span>$</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/aca988e296a3559e4d15666e69088ec8c24d2a68e146b066f7f0e03a6ee65f35.png" src="../../_images/aca988e296a3559e4d15666e69088ec8c24d2a68e146b066f7f0e03a6ee65f35.png" />
</div>
</div>
<p>To get an intuition why it is called a rotation around the Y axis, let’s plot it on the Bloch sphere:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7d07ea3a57fbe73167f27f412b2c4676b7c242e7309a59abc7220dfe7d5bee6c.png" src="../../_images/7d07ea3a57fbe73167f27f412b2c4676b7c242e7309a59abc7220dfe7d5bee6c.png" />
</div>
</div>
<p>It does exactly what it says: it rotates from the north pole of the Bloch sphere.</p>
<p>Why is interesting to have complex probability amplitudes instead of non-negative real numbers? To get some insight, take a look what happens if we apply the same rotation to <span class="math notranslate nohighlight">\(|1\rangle\)</span>. To achieve this, first we flip <span class="math notranslate nohighlight">\(|0\rangle\)</span> to <span class="math notranslate nohighlight">\(|1\rangle\)</span> by applying a NOT gate (denoted by X in quantum computing) and then the rotation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/055ff131c382ea1ed8ddefed674753e8799bb1907585f14a695136793f1c8b80.png" src="../../_images/055ff131c382ea1ed8ddefed674753e8799bb1907585f14a695136793f1c8b80.png" />
</div>
</div>
<p>We can verify that the result is
$<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(-|0\rangle + |1\rangle)\)</span>$
That is, the exact same state as before, except that the first term got a minus sign: it is a negative probability amplitude. Note that the difference cannot be observed from the statistics:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/86144182a1afcde982fa6c7a27347c20165e38bb141c4e5219766d1c80b72683.png" src="../../_images/86144182a1afcde982fa6c7a27347c20165e38bb141c4e5219766d1c80b72683.png" />
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="interference">
<h1>Interference<a class="headerlink" href="#interference" title="Permalink to this headline"></a></h1>
<p>Interference is a strange phenomenon where the different basis vectors and the coefficients interact in your calculations.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\mid0\rangle=\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\left[\begin{array}{c} 1\\1\end{array}\right]=\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)\end{split}\]</div>
<p>So imagine that you act on your 0 ket with this particular matrix. Remember that, in your transform stochastic vectors, with matrices, with stochastic matrices, to ensure that the result is also a stochastic vector, a probability distribution, quantum states are also acted on by these operators, and they fulfill certain conditions that we will learn later. Now, just accept that this is a valid operation, and it transform the 0 ket into the equal superposition of the 0 and the 1 ket. And, if you are acting on the 1 ket, the only difference would be that it would introduce a negative sign to the 0 ket.</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{2}}(-\mid0\rangle+\mid1\rangle\]</div>
<p>Interestingly is, if we now take this outcome
$<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)\)</span>$
and we apply the same operation on it– that’s what we are doing here– so I take this outcome, and I apply the same operation on it– then something interesting is happening. So this is a linear operator, so I can pull out the 1 over square root 2 the front, so it simplifies to 1/2. And I can also take the matrix operation basis vector by basis vector in the superposition.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)=\frac{1}{2}\left(\mid0\rangle+\mid1\rangle-\mid0\rangle+\mid1\rangle\right)\end{split}\]</div>
<p>So I act on the first one. From that, I get the superposition of 0 and 1 <span class="math notranslate nohighlight">\(\mid0\rangle+\mid1\rangle\)</span>, just like here, the same thing. And then I have the 1 ket, so I’m going to get this outcome, which we calculated here. And now, if you look at this, these two cancel out</p>
<div class="math notranslate nohighlight">
\[\require{cancel}\]</div>
<div class="math notranslate nohighlight">
\[\frac{1}{2}\left(\cancel{\mid0\rangle}+\mid1\rangle-\cancel{\mid0\rangle}+\mid1\rangle\right)\]</div>
<p>Which means that we get a deterministic outcome by applying the operator again. So this is an example of interference. So t he probability amplitudes of the 0 ket destructive interfere, they vanish from the superposition, and you get the deterministic 1 outcome.</p>
<section id="quiz-quantum-states">
<h2>Quiz Quantum States<a class="headerlink" href="#quiz-quantum-states" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Is
$<span class="math notranslate nohighlight">\(\frac{1}{3}\mid0\rangle+\sqrt{\frac{2}{3}}\mid1\rangle\)</span>$
a valid quantum state?</p></li>
</ul>
<p><strong>False</strong></p>
<ul class="simple">
<li><p>In a quantum state, the probability amplitudes are not restricted to the positive orthant. This is what enables interference.</p></li>
</ul>
<p><strong>True</strong></p>
<ul class="simple">
<li><p>The points on the surface of the Bloch sphere…</p></li>
</ul>
<p><strong>are qubit states</strong></p>
<p>It still looks like an approximately unbiased coin. Yet, that negative sign – or any complex value – is what models <em>interference</em>, a critically important phenomenon where probability amplitudes can interact in a constructive or a destructive way. To see this, if we apply the rotation twice in a row on
$<span class="math notranslate nohighlight">\(|0\rangle\)</span><span class="math notranslate nohighlight">\( 
we get another deterministic output, 
\)</span><span class="math notranslate nohighlight">\(1\rangle\)</span>$
although in between the two, it was some superposition.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/d20567d853f2cdeba09477e546dae46b177d0ea20645be32af9e539b973d6212.png" src="../../_images/d20567d853f2cdeba09477e546dae46b177d0ea20645be32af9e539b973d6212.png" />
</div>
</div>
<p>Many quantum algorithms exploit interference, for instance, the seminal <a class="reference external" href="https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm">Deutsch-Josza algorithm</a>, which is among the simplest to understand its significance.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="more-qubits-and-entanglement">
<h1>More qubits and entanglement<a class="headerlink" href="#more-qubits-and-entanglement" title="Permalink to this headline"></a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="multiple-qubits-revisited">
<h1>Multiple Qubits revisited<a class="headerlink" href="#multiple-qubits-revisited" title="Permalink to this headline"></a></h1>
<p>Starting with the simplest possible quantum system, a qubit state and try to construct larger probability distributions, or larger states, which are composed of several qubits. Before we go there, we have to introduce a new mathematical operation, a tensor product. Imagine that you have two quantum states, two kets. One has a probability amplitudes a0 a1, and the second one has b0 and b1.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi'\rangle=\left[\begin{array}{c}b_{0}\\b_{1}\end{array}\right]\end{split}\]</div>
<p>Now, then, we can define this tensor product as this object.</p>
<div class="math notranslate nohighlight">
\[\begin{split}|\psi\rangle\otimes|\psi\prime\rangle=\left[\begin{array}{c}a_{0}b_{0}\\a_{0}b_{1}\\a_{1}b_{0}\\a_{1}b_{1}\end{array}\right]\end{split}\]</div>
<p>First we have
$<span class="math notranslate nohighlight">\(a_{0} \otimes b_{0}\)</span><span class="math notranslate nohighlight">\(
as the first component, and you have 
\)</span><span class="math notranslate nohighlight">\(a_{0} \otimes b_{1}\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(a_{1} \otimes b_{0}\)</span><span class="math notranslate nohighlight">\(
which is a four-dimensional complex vector. These are independently two-dimensional complex vectors, and here we create a four-dimensional one. And now we can also look at this probability distribution-- has four possible outcomes. We can create a basis, in this space by taking our \)</span>0<span class="math notranslate nohighlight">\( ket and take the tensor product of the other \)</span>0$ kets.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid0\rangle\otimes\mid0\rangle=\mid0\rangle\mid0\rangle=\mid00\rangle=\left[\begin{array}{c}1\\0\\0\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid0\rangle\otimes\mid1\rangle=\mid0\rangle\mid1\rangle=\mid01\rangle=\left[\begin{array}{c}0\\1\\0\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid1\rangle\otimes\mid0\rangle=\mid1\rangle\mid0\rangle=\mid11\rangle=\left[\begin{array}{c}0\\0\\1\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid1\rangle\otimes\mid1\rangle=\mid1\rangle\mid1\rangle=\mid11\rangle=\left[\begin{array}{c}0\\0\\0\\1\end{array}\right]\end{split}\]</div>
<p>Convention right most qubit is qubit <span class="math notranslate nohighlight">\(0\)</span></p>
<p>The shorthand notation for this is just dropping the tensor product sign. Even shorter notation is by dropping the two kets, here, and just contracting them into one. And if we calculate the product, then we end up with the first canonical basis vector of the four-dimensional space. The same thing with 0 and 1, 1 0, and 1 1. Noticing that these are the four possibilities, the four canonical basis vectors, in the four-dimensional complex space. There’s a very important convention that most quantum-computing libraries out there use, which is that it’s the rightmost qubit which is the qubit 0. This would be qubit 0. And then to the left of it would be qubit 1, and so on, and so forth.<br>
This is the same order of representing binary values as you would have in most digital computers, and that’s why this convention is maintained in these quantum-computing frameworks. These are called “product states,” but there are also states which cannot be written in this form, even though they live in the same space. One example is the <span class="math notranslate nohighlight">\(\phi+\)</span> state.</p>
<div class="math notranslate nohighlight">
\[\mid\psi\rangle\otimes|\psi\prime\rangle\in C^{2}\otimes C^{2}\]</div>
<p>It’s written as an equal superposition of two basis vectors, 0 0 and 1 1, so it’s definitely in the same space as our product vector.</p>
<div class="math notranslate nohighlight">
\[\phi^{\dagger'}=\frac{1}{\sqrt{2}}(\mid00\rangle+\mid11\rangle)\in C^{2}\otimes C^{2}\]</div>
<p>But it cannot be written as a product vector. And, to see that, let’s take a look at the general structure of this product vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle\otimes|\psi\prime\rangle=\left[\begin{array}{c}a_{0}b_{0}\\a_{0}b_{1}\\a_{1}b_{0}\\a_{1}b_{1}\end{array}\right]=a_{0}b_{0}\mid00\rangle+a_{0}b_{10}\mid01\rangle+a_{1}b_{0}\mid10\rangle+a_{1}b_{1}\mid11\rangle\end{split}\]</div>
<p>We copied the definition of the product vector here and wrote it down in the canonical basis. It would have a0 times b0 times the 0 0 ket, and so on. It has four components. And let us assume that there is some combination of these ai and bj values such that we can write this phi plus state as a product state.</p>
<div class="math notranslate nohighlight">
\[\phi^{\dagger'} = \mid\psi\rangle\otimes\mid\psi\prime\rangle\]</div>
<p>So this means that, either here we have 0 0 ket with a coefficient 1 over square root 2– so this equation must be fulfilled.</p>
<div class="math notranslate nohighlight">
\[a_{0}b_{0}=\frac{1}{\sqrt{2}}\qquad a_{0}b_{1}=0\]</div>
<div class="math notranslate nohighlight">
\[\underbrace{a_{0}b_{0}=\frac{1}{\sqrt{2}}}_{\text{Entangled state}}\qquad a_{1}b_{0}=0\]</div>
<p>Similarly, we have the <span class="math notranslate nohighlight">\(1 1\)</span> ket with the same coefficient. This condition must be fulfilled. And we also see that there is no 0 1 and 1 0, so the corresponding coefficient must be 0. But now, it means that either a0 or b1 must be 0. a0 cannot be 0, because it multiplies to some known nonzero value, but the same is true for b1. Therefore the state, although it lives in the same space, cannot be written as a product state. Such states are called “entangled states,” and they play a very important role in quantum computing, together with interference. So these are the main quantum-mechanical properties that we exploit in quantum calculations, as you will see in subsequent lectures.</p>
<section id="quiz">
<h2>Quiz<a class="headerlink" href="#quiz" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The <span class="math notranslate nohighlight">\(\mid00\rangle\)</span> state is the same as…
$<span class="math notranslate nohighlight">\(\mid0\rangle\otimes\mid0\rangle\)</span>$</p></li>
</ul>
<p>– the first basis vector in the canonical basis in four dimensions.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c}1 \\0\\0\\0\end{array}\right]\end{split}\]</div>
<p>Since the basis of
$<span class="math notranslate nohighlight">\(\mathbb{C}^{2}\otimes\mathbb{C}^{2}\)</span>$
is created as product states, all states in this space must be product states.</p>
<p><strong>False</strong></p>
<p>We have already seen that quantum states are probability distributions normed to <span class="math notranslate nohighlight">\(1\)</span> in the <span class="math notranslate nohighlight">\(l_{2}\)</span> norm and we got a first peek at interference. If we introduce more qubits, we see another crucial quantum effect emerging. To do that, we first have to define how we write down the column vector for describing two qubits. Using a tensor product, which, in the case of qubits, is equivalent to the Kronecker product. Given two qubits,
$<span class="math notranslate nohighlight">\(\mid\psi\rangle=\begin{bmatrix}a_0\\a_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
and 
\)</span><span class="math notranslate nohighlight">\(\mid\psi'\rangle=\begin{bmatrix}b_0\\b_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
their product is 
\)</span><span class="math notranslate nohighlight">\(\mid\psi\rangle\otimes\mid\psi'\rangle = \begin{bmatrix}a_0b_0\\ a_0b_1\\ a_1b_0\\ a_1b_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
Imagine that you have two registers 
\)</span>q_{0}<span class="math notranslate nohighlight">\( and \)</span>q_{1}<span class="math notranslate nohighlight">\( 
each can hold a qubit, and both qubits are in the state 
\)</span><span class="math notranslate nohighlight">\(\mid 0\rangle\)</span>$
Then this composite state would be described by according to this product rule as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">q0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1],
       [0],
       [0],
       [0]])
</pre></div>
</div>
</div>
</div>
<p>This is the <span class="math notranslate nohighlight">\(|0\rangle\otimes|0\rangle\)</span> state, which we often abbreviate as <span class="math notranslate nohighlight">\(|00\rangle\)</span>. The states <span class="math notranslate nohighlight">\(|01\rangle\)</span>, <span class="math notranslate nohighlight">\(|10\rangle\)</span>, and <span class="math notranslate nohighlight">\(|11\rangle\)</span> are defined analogously, and the four of them give the canonical basis of the four dimensional complex space, <span class="math notranslate nohighlight">\(\mathbb{C}^2\otimes\mathbb{C}^2\)</span>.</p>
<p>Now comes the interesting and counter-intuitive part. In machine learning, we also work with high-dimensional spaces, but we never construct it as a tensor product: it is typically <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span> for some dimension <span class="math notranslate nohighlight">\(d\)</span>. The interesting part of writing the high-dimensional space as a tensor product is that not all vectors in can be written as a product of vectors in the component space.</p>
<p>Take the following state: <span class="math notranslate nohighlight">\(|\phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)</span>. This vector is clearly in <span class="math notranslate nohighlight">\(\mathbb{C}^2\otimes\mathbb{C}^2\)</span>, since it is a linear combination of two of the basis vector in this space. Yet, it cannot be written as <span class="math notranslate nohighlight">\(|\psi\rangle\otimes|\psi'\rangle\)</span> for some <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, <span class="math notranslate nohighlight">\(|\psi'\rangle\in\mathbb{C}^2\)</span>.</p>
<p>To see this, assume that it can be written in this form. Then</p>
<div class="math notranslate nohighlight">
\[\begin{split}
|\phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle) = \begin{bmatrix}a_0b_0\\ a_0b_1\\ a_1b_0\\ a_1b_1\end{bmatrix} = a_0b_0|00\rangle + a_0b_1|01\rangle + a_1b_0|10\rangle + a_1b_1|11\rangle.
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(|01\rangle\)</span> and <span class="math notranslate nohighlight">\(|10\rangle\)</span> do not appear on the left-hand side, so their coefficients must be zero: <span class="math notranslate nohighlight">\(a_1b_0=0\)</span> and <span class="math notranslate nohighlight">\(a_0b_1=0\)</span>. This leads to a contradiction, since <span class="math notranslate nohighlight">\(a_1\)</span> cannot be zero (<span class="math notranslate nohighlight">\(a_1b_1=1\)</span>), so <span class="math notranslate nohighlight">\(b_0\)</span> must be zero, but <span class="math notranslate nohighlight">\(a_0b_0=1\)</span>. Therefore <span class="math notranslate nohighlight">\(|\phi^+\rangle\)</span> cannot be written as a product.</p>
<p>States that cannot be written as a product are called entangled states. This is the mathematical form of describing a phenomenon of strong correlations between random variables that exceed what is possible classically. Entanglement plays a central role in countless quantum algorithms. A simple example is <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_teleportation">quantum teleportation</a>. We will also see its applications in quantum machine learning protocols.</p>
<p>We will have a closer look at entanglement in a subsequent notebook on measurements, but as a teaser, let us look at the measurement statistics of the <span class="math notranslate nohighlight">\(|\phi^+\rangle\)</span> state. The explanation of the circuit preparing it will also come in a subsequent notebook.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/ff590da60f36d6fad0a21a3f7eb04b9a02daa1db1555fd000bc899037dd97702.png" src="../../_images/ff590da60f36d6fad0a21a3f7eb04b9a02daa1db1555fd000bc899037dd97702.png" />
</div>
</div>
<p>Notice that 01 or 10 never appear in the measurement statistics.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="further-reading">
<h1>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline"></a></h1>
<p>Chapter 9 in Quantum Computing since Democritus by Scott Aaronson describes a similar approach to understanding quantum states – in fact, the interference example was lifted from there.</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./qml/1_quantum_systems"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="1_quantum_systems.html" class="btn btn-neutral float-left" title="Quantum Systems" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../2_quantum_computations/2_quantum_computations.html" class="btn btn-neutral float-right" title="Quantum Computations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>